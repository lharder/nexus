local Events = require( "level.playground.events" )
local lua = require( "deflibs.lualib" )
local vcontroller = require( "in.onscreen" )

go.property( "speed", 0 )
go.property( "isLocalHero", false )


local MSG_ON_FIRST_TICK = hash( "firsttick" )
local MSG_STICK 		= hash( "stick" )
local MSG_BUTTON 		= hash( "button" )

local LEFT = hash( "left" )
local RIGHT = hash( "right" )
local UP = hash( "up" )
local DOWN = hash( "down" )


local function updateRemote( self, dt )
	-- Move towards a target in a straight line. Target is
	-- provided by remote player, this is only a drone gameobject
	self.pos = go.get_position()
	self.dir = vmath.normalize( self.targetPos - self.pos )
	self.pos.x = self.pos.x + self.dir.x * self.speed * dt
	self.pos.y = self.pos.y + self.dir.y * self.speed * dt
	go.set_position( self.pos )

	if 	lua.approximates( self.pos.x, self.targetPos.x, 2 ) and
		lua.approximates( self.pos.y, self.targetPos.y, 2 ) then
		-- pprint( self.gid .. " reached pos" )
		self.targetPos = nil
		self.dir.x = 0
		self.dir.y = 0
	end
end



local function updateManual( self, dt )
	-- no target selected (by a remote player), so it is this
	-- gameobject that must react to input and transmit positions
	self.pos = go.get_position()
	self.oldPos = go.get_position()

	self.pos = go.get_position()
	self.pos.x = self.pos.x + self.dir.x * self.speed * dt
	self.pos.y = self.pos.y + self.dir.y * self.speed * dt
	go.set_position( self.pos )

	if( self.isLocalHero ) then 
		-- Distance covered before a new position is transmitted 
		-- to the other clients: depends on go's speed!
		self.dist = math.abs( vmath.length( self.pos - self.oldPos ) )
		if self.dist >= 1 then
			local evt = Events.newMoveTo( self.gid, self.pos )
			GAME.client:sendToOtherClients( evt )
		end
	end
end


local function vcontrol( self, action )
	if action.id == MSG_STICK then
		if action.released then
			-- keep direction, stop moving
			self.speed = 0
		else
			-- move in the desired direction
			if( math.abs( action.x ) > 0 ) or ( math.abs( action.y ) > 0 ) then 
				self.speed = self.maxSpeed
				self.dir.x = action.x
				self.dir.y = action.y	
			end
		end		
		
	elseif action.id == MSG_BUTTON then
		if action.pressed then self.buttons[ action.id ] = true end	
		if action.released then self.buttons[ action.id ] = false end	
	end
end


local function parse( self, message )
	if message.meta.type == Events.MOVE_TO then
		if message.attrs.pos then 
			-- Target's position is probably outdated when received here 
			-- already. To compensate, assume that target has continued to 
			-- move in the same direction: calcluate direction and add a
			-- custom factor depending on the network latency
			self.targetPos = message.attrs.pos
			self.dir = vmath.normalize( self.targetPos - self.pos )
			self.targetPos = self.targetPos + self.dir * self.speed * 0,06

			-- Honestly: not completely understood. When moving into position
			-- diagonally, the remote object is slower than the original.
			-- Apparently, the movement is "up" then "right", not "up right"
			-- most of the times because of interpolation. Compensate by 
			-- higher speed (diagonal = 1.4 steps length instead of 2)
			if self.dir.x == 0 or self.dir.y == 0 then
				self.speed = self.maxSpeed
			else
				self.speed = self.maxSpeed * 1.4
			end
		end
	end
end


function init( self )
	self.dir = vmath.vector3()
	self.maxSpeed = self.speed

	-- important: user input only from the one per host / right client!
	if self.isLocalHero then 
		-- listen to keyboard 
		msg.post( ".", "acquire_input_focus" ) 

		-- set me up as listener for virtual touch controller
		msg.post( "vcontroller", "register" )
		-- state of virtual buttons: pressed/not?
		self.buttons = {}
	end
	
	msg.post( ".", MSG_ON_FIRST_TICK )
end


function update( self, dt )
	if self.targetPos == nil then
		updateManual( self, dt )
	else
		updateRemote( self, dt )
	end
end


function on_message( self, message_id, message, sender )
	if message_id == MSG_ON_FIRST_TICK then 
		-- get my global id, does not work on init()
		-- cannot pass in string params on factory.create...
		self.gid = GAME.client.registry:getGlobalId( go.get_id() )

	elseif message_id == vcontroller.ANALOG then 
		vcontrol( self, message )

	elseif message_id == GAME.MSG_EXEC_CMD then 
		parse( self, message )
	end
end



