local Events = require( "level.playground.events" )
local lua = require( "deflibs.lualib" )

go.property( "speed", 0 )
go.property( "isLocalHero", false )


local MSG_ON_FIRST_TICK = hash( "firsttick" )

local LEFT = hash( "left" )
local RIGHT = hash( "right" )
local UP = hash( "up" )
local DOWN = hash( "down" )


local function updateRemote( self, dt )
	-- Move towards a target in a straight line. Target is
	-- provided by remote player, this is only a drone gameobject
	self.pos = go.get_position()
	self.dir = vmath.normalize( self.targetPos - self.pos )
	self.pos.x = self.pos.x + self.dir.x * self.speed * dt
	self.pos.y = self.pos.y + self.dir.y * self.speed * dt
	go.set_position( self.pos )

	if 	lua.approximates( self.pos.x, self.targetPos.x, 2 ) and
		lua.approximates( self.pos.y, self.targetPos.y, 2 ) then
		-- pprint( self.gid .. " reached pos" )
		self.targetPos = nil
		self.dir.x = 0
		self.dir.y = 0
	end
end



local function updateManual( self, dt )
	-- no target selected (by a remote player), so it is this
	-- gameobject that must react to input and transmit positions
	self.pos = go.get_position()
	self.oldPos = go.get_position()

	self.pos = go.get_position()
	self.pos.x = self.pos.x + self.dir.x * self.speed * dt
	self.pos.y = self.pos.y + self.dir.y * self.speed * dt
	go.set_position( self.pos )

	if( self.isLocalHero ) then 
		-- Distance covered before a new position is transmitted 
		-- to the other clients: depends on go's speed!
		self.dist = math.abs( vmath.length( self.pos - self.oldPos ) )
		if self.dist >= 1 then
			local evt = Events.newSetPlayerPos( self.gid, self.pos )
			GAME.client:sendToOtherClients( evt )
		end
	end
end



local function parse( self, message )
	if message.meta.type == Events.SET_PLAYER_POS then
		if message.attrs.pos then 
			-- Target's position is probably outdated when received here 
			-- already. To compensate, assume that target has continued to 
			-- move in the same direction: calcluate direction and add a
			-- custom factor depending on the network latency
			self.targetPos = message.attrs.pos
			self.dir = vmath.normalize( self.targetPos - self.pos )
			self.targetPos = self.targetPos + self.dir * self.speed * 0,06

			-- Honestly: not completely understood. When moving into position
			-- diagonally, the remote object is slower than the original.
			-- Apparently, the movement is "up" then "right", not "up right"
			-- most of the times because of interpolation. Compensate by 
			-- higher speed (diagonal = 1.4 steps length instead of 2)
			if self.dir.x == 0 or self.dir.y == 0 then
				self.speed = self.origSpeed
			else
				self.speed = self.origSpeed * 1.4
			end
		end
	end
end


function init( self )
	self.dir = vmath.vector3()
	self.origSpeed = self.speed
	
	msg.post( ".", MSG_ON_FIRST_TICK )
end


function on_input( self, action_id, action )
	if action_id == LEFT then
		if action.pressed then self.dir.x = -1 end
		if action.released then self.dir.x = 0 end
	end
	if action_id == RIGHT then
		if action.pressed then self.dir.x =  1 end
		if action.released then self.dir.x = 0 end
	end
	if action_id == UP then
		if action.pressed then self.dir.y = 1 end
		if action.released then self.dir.y = 0 end
	end
	if action_id == DOWN then
		if action.pressed then self.dir.y = -1 end
		if action.released then self.dir.y = 0 end
	end
end


function update( self, dt )
	if self.targetPos == nil then
		updateManual( self, dt )
	else
		updateRemote( self, dt )
	end
end


function on_message( self, message_id, message, sender )
	if message_id == MSG_ON_FIRST_TICK then 
		-- get my global id, does not work on init()
		-- cannot pass in string params on factory.create...
		self.gid = GAME.client.registry:getGlobalId( go.get_id() )

	elseif message_id == GAME.MSG_EXEC_CMD then 
		parse( self, message )
	end
end



